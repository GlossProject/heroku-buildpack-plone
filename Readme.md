heroku config:add BUILDPACK_URL=http://github.com/kr/heroku-buildpack-inline.git


Heroku buildpack: Plone
=======================

This is a [Heroku buildpack](http://devcenter.heroku.com/articles/buildpacks) for Plone apps, powered by [zc.buildout](http://www.buildout.org/en/latest/).

Plone on Heroku
---------------

To make Plone run on Heroku you need to add the configuration to your
``buildout.cfg`` file::

    [buildout]
    relative-paths = true

    [instance]
    recipe = plone.recipe.zope2instance
    relative-paths = true
    eggs +=
        RelStorage
        psycopg2
    rel-storage =
        keep-history false
        blob-dir /tmp/blobcache
        shared-blob-dir false
        type postgresql
        host PG_HOST
        dbname PG_DBNAME
        user PG_USER
        password PG_PASS

A sample minimal ``buildout.cfg`` is provided in this repo, just look above :).

There are two things to you need to know about Heroku to understand the changes
above:

1. Heroku's unit of computation is called a [dyno](https://devcenter.heroku.com/articles/dynos). Think of it as a single server instance.

2. Heroku has a two-step deployment workflow: First you compile a runtime slug (``bin/buildout`` in our case), then Heroku copies this slug to a dyno and runs your app code against the slug (``bin/instance console`` in our case). Because of the fact that ``bin/buildout`` is ran in a different place than ``bin/instance`` we need to fix some paths generated by buildout. We get half-way there with the ``relative-paths`` flag and then use ``sed`` to fix the rest of the paths in ``zope.conf`` that buildout generated for us.

3. At the compile time (``bin/buildout`` in our case) we do not yet know on which port Plone will run -- this is given as an environment variable when running the runtime slug on a dyno. However Plone does not have any way of either using environment variables in ``zope.conf`` or reading command-line parameters when starting up with ``bin/instance``. So we ship a ``configure_zopeconf.py`` script that reads env values and uses search/replace to inject them into ``zope.conf``. We run this script just before starting the Plone instance on the dyno.

4. Lastly, Heroku has ephemeral filesystem, meaning you loose all data when a dyno restarts. Luckly
Heroku provides world-class Postgres-as-a-service persistency option. We just need to configure
Plone to use ``RelStorage`` which gives it support for relational databases. DB connection settings
are set by the ``configure_zopeconf.py`` script, which reads them from environment variables.

5. On free-tier Heroku gives you one dyno instance per month. Forever. However, if there are no requests to your site withing an hour, Heroku will put the dyno to sleep. When the next request comes there will be some delay before a response is sent back (~20s for heroku startup, ~20s for Plone startup), but subsequent requests will be served at a normal speed.

6. The free-tier PostgreSQL DB that you get with this buildpack has a limit of 10.000 rows. To keep clear of this limit the ``buildout.cfg`` above sets the ``keep-history false`` flag to not keep transactional history. This means that you loose the `Undo` feature, but you do keep the document history, your DB remains small and manageable and you do not need to regularly "pack" your DB.


Usage
-----

Example usage:

    $ ls
    buildout.cfg

    $ heroku create --buildpack git://github.com/niteoweb/heroku-buildpack-plone.git

    $ git push heroku master
    ...
    -----> Plone app detected
    -----> Use build cache
           Get buildout results from the previous build
    -----> Bootstrap buildout
           ...
    -----> Run bin/buildout
           ...
    -----> Fix paths in zope.conf
    -----> Copy results to cache
    -----> Copy results to slug
    -----> Copy configure_zopeconf.py script to slug
    -----> Discovering process types
           Procfile declares types    -> (none)
           Default types for Plone -> web

    $ heroku open

The buildpack will detect your app as Plone if it has the file `buildout.cfg` in the root. It will use `zc.buildout` to install your dependencies, vendoring a copy of the Plone runtime into your slug. It will define a default ``Procfile`` (so you don't have to manually create it) and provision a free-tier PostgreSQL database for persistence.

